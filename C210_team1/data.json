{
  
  "intro": [
    {
      "type": "cover",
      "title": "C210 communication skills",
      "big_text": "FULL SYSTEM",
      "subtitle": "Complete Source Code Review"
    },
    {
      "type": "team",
      "title": "Team Member",
      "members": [
        "ðŸ‘¥ Ji Xun: library.py ",
        "ðŸ‘¤ wee kiat: library.py ",
        "ðŸ‘¤ zhi ying: transact.py ",
        "ðŸ‘¤ ally: book.py, user.py, constants.py ",
        "ðŸ‘¤ sherlyn: main.py ",
        "ðŸ‘¤ Kai Duo: tools.py (Main program assistant tools)"
      ]
    }

  ],
  "units": [
    {
      "id": "1",
      "title": "library.py",
      "code": "# library.py\nfrom datetime import datetime, date\nimport pandas as pd\nfrom constants import TRANS_TYPE_BORROW, TRANS_TYPE_RETURN, TRANS_TYPE_ALL\n\n# Type hinting imports\nfrom book import Book \nfrom transact import Transact\nfrom user import User\n\nclass Library:\n    def __init__(self, name, area, country):\n        self.__name = str(name)\n        self.__area = str(area)\n        self.__country = str(country)\n        # Storage Dictionaries\n        self.__books = {}     # {callNo: Book}\n        self.__users = {}     # {userID: User}\n        self.__transacts = {} # {transactID: Transact}\n\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # Getters\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    def get_books_dict(self): return self.__books\n    def get_users_dict(self): return self.__users\n    def get_transacts_dict(self): return self.__transacts\n\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # Helper Methods (Internal Logic)\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    def __is_book_borrowed(self, call_no: str) -> bool:\n        \"\"\"\n        Internal Helper: Scans all transactions to see if a specific book \n        is currently checked out (i.e., returnDate is None).\n        \n        Args:\n            call_no: The unique identifier of the book.\n        Returns:\n            True if the book is currently borrowed, False otherwise.\n        \"\"\"\n        for transact in self.__transacts.values():\n            # Accessing the private Transact attribute via Getter or direct inspection (within system trust)\n            # We assume Transact has a public getter for Book or we access the object structure.\n            # Here we rely on Transact.book object comparison or CallNo comparison.\n            \n            # Note: transact.book is a Book object.\n            if transact.book.getCallNo() == call_no and transact.returnStatus() is None:\n                return True\n        return False\n\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # Book Management\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    def addBook(self, new_book: Book):\n        \"\"\"\n        Req 1: Check that only books with a unique callNo can be added.\n        \"\"\"\n        if new_book:\n            callNo = new_book.getCallNo()\n            \n            # Validation: Uniqueness Check\n            if callNo in self.__books:\n                print(f\" !! Error: Violation of Unique Constraint. Book with CallNo '{callNo}' already exists.\")\n            else:\n                self.__books[callNo] = new_book\n                print(f\" >> Success: Book '{new_book.getCallNo()}' added to library.\")\n\n    def deleteBook(self):\n        \"\"\"\n        Req 3: Remove Book by callNo AND all related Transacts.\n        Constraint: Only if book is NOT borrowed out.\n        \"\"\"\n        target_call_no = input(\"Enter Call No of the book to delete: \").strip()\n\n        # 1. Existence Check\n        if target_call_no not in self.__books:\n            print(f\" !! Error: Book '{target_call_no}' not found in library.\")\n            return\n\n        # 2. Availability Check (Guard Clause)\n        if self.__is_book_borrowed(target_call_no):\n            print(f\" !! Action Denied: Book '{target_call_no}' is currently BORROWED out.\")\n            print(\"    You must return the book before deleting it.\")\n            return\n\n        # 3. Execution: Cascade Delete\n        # Step A: Identify related transaction IDs\n        # We use a list comprehension to gather IDs first to avoid modifying dictionary while iterating\n        related_trans_ids = [\n            tid for tid, trans in self.__transacts.items() \n            if trans.book.getCallNo() == target_call_no\n        ]\n\n        # Step B: Delete from Book Repository\n        deleted_book = self.__books.pop(target_call_no)\n        \n        # Step C: Delete related Transactions\n        for tid in related_trans_ids:\n            del self.__transacts[tid]\n\n        print(f\" >> Success: Book '{deleted_book.getCallNo()}' deleted.\")\n        print(f\" >> Cascade Update: Removed {len(related_trans_ids)} historical transaction records associated with this book.\")\n\n    def displayBooks(self):\n        print(\"\\n--- Library Books ---\")\n        if not self.__books:\n            print(\" (Library is empty)\")\n        else:\n            i = 1 \n            for book in self.__books.values():\n                # Visual indicator if book is borrowed\n                status = \"[BORROWED]\" if self.__is_book_borrowed(book.getCallNo()) else \"[AVAILABLE]\"\n                print(f\"{i}. {book.getCallNo()} {status} (Title: {str(book).splitlines()[1]})\")\n                i += 1\n            print(\"-\" * 20)\n\n    def getBook(self):\n        callNo = input(\"Enter Call No to search: \")\n        book = self.__books.get(callNo)\n        if book: \n            status = \"Borrowed\" if self.__is_book_borrowed(callNo) else \"Available\"\n            print(f\" >> Found ({status}): \\n{book}\")\n        else: \n            print(\" !! Book not found.\")\n\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # User Management (Unchanged from previous iteration)\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    def addUser(self, new_user: User):\n        if new_user:\n            userID = new_user.getUserID()\n            if userID in self.__users:\n                 print(\" !! Error: User ID already exists.\")\n            else:\n                self.__users[userID] = new_user\n                print(\" >> User added successfully.\")\n\n    def displayUsers(self):\n        print(\"\\n--- Library Users ---\")\n        i = 1 \n        for user in self.__users.values():\n            print(f\"{i}. {user.getName()} (ID: {user.getUserID()})\")\n            i += 1\n\n    def getUser(self): \n        uid = input(\"Enter User ID to search: \")\n        user = self.__users.get(uid)\n        if user: print(f\" >> Found: \\n{user}\")\n        else: print(\" !! User not found.\")\n\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # Transaction Management\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    def borrowTransact(self, new_transact: Transact):\n        \"\"\"\n        Req 2: Check that attempts to borrow a book that was previously borrowed are disallowed.\n        \"\"\"\n        if new_transact:\n            # Extract the book object from the transaction wrapper\n            target_book = new_transact.book \n            call_no = target_book.getCallNo()\n\n            # Validation 1: Check if the book actually exists in the library registry\n            # (This prevents borrowing a book that was created ad-hoc but not registered)\n            if call_no not in self.__books:\n                print(f\" !! Error: Book '{call_no}' is not registered in this library system.\")\n                return\n\n            # Validation 2: Check Availability (The New Requirement)\n            if self.__is_book_borrowed(call_no):\n                print(f\" !! Transaction Rejected: Book '{call_no}' is already borrowed.\")\n                return\n\n            # Validation 3: Check Duplicate Transaction ID\n            tid = new_transact.getTransactID()\n            if tid in self.__transacts:\n                print(f\" !! Error: Transaction ID '{tid}' already exists.\")\n                return\n\n            # If all checks pass, commit the transaction\n            self.__transacts[tid] = new_transact\n            print(f\" >> Success: Transaction recorded. Book '{call_no}' is now marked as borrowed.\")\n\n    def displayTransact(self):\n        print(f\"1. Borrowed Books (Outstanding)\")\n        print(f\"2. Returned Books (History)\")\n        print(f\"3. All Transactions\")\n        \n        t_type = input(\"Enter view filter: \")\n        \n        print(\"\\n--- Transaction Records ---\")\n        found = False\n        for transact in self.__transacts.values():\n            status = transact.returnStatus() # Returns date or None\n            \n            # Logic: Borrowed (status is None), Returned (status is Date)\n            is_borrowed = status is None\n            \n            if (t_type == TRANS_TYPE_BORROW and is_borrowed) or \\\n               (t_type == TRANS_TYPE_RETURN and not is_borrowed) or \\\n               (t_type == TRANS_TYPE_ALL):\n                print(transact)\n                print(\"-\" * 20)\n                found = True\n        \n        if not found: print(\"No records found for this category.\")\n\n    def returnTransact(self): \n        tid = input(\"Enter Transaction ID to return: \")\n        transact = self.__transacts.get(tid)\n        \n        if transact:\n            if transact.returnStatus() is not None:\n                print(\" !! This transaction is already returned.\")\n            else:\n                transact.returnTransact() \n                print(f\" >> Book returned successfully. Fine updated: {transact}\")\n        else:\n            print(\" !! Transaction ID not found.\")\n            \n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # Persistence\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    def save(self):\n        try:\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            \n            books_data = [vars(b) for b in self.__books.values()]\n            pd.DataFrame(books_data).to_excel(f\"books_{timestamp}.xlsx\")\n            \n            users_data = [vars(u) for u in self.__users.values()]\n            pd.DataFrame(users_data).to_excel(f\"users_{timestamp}.xlsx\")\n            \n            # Transactions are complex, mapping relevant details for flat storage\n            trans_data = []\n            for t in self.__transacts.values():\n                row = {\n                    \"TransactID\": t.getTransactID(),\n                    \"BookCallNo\": t.book.getCallNo(),\n                    \"UserID\": t.user.getUserID(),\n                    \"BorrowDate\": t._Transact__borrowDate,\n                    \"ReturnDate\": t._Transact__returnDate,\n                    \"Fine\": t._Transact__fine\n                }\n                trans_data.append(row)\n\n            pd.DataFrame(trans_data).to_excel(f\"transacts_{timestamp}.xlsx\")\n            \n            print(\" >> Data saved to Excel files.\")\n        except Exception as e:\n            print(f\" !! Error saving data: {e}\")\n\n    def __str__(self):\n        return f\"{self.__name} ({self.__area}, {self.__country})\"",
      "steps": [
        {
          "seq": "1.1",
          "lines": [67, 86],
          "caption": "Efficiency",
          "add": [
            {
              "anchor": "__is_book_borrowed",
              "title": "Private Helper",
              "content": "This method is internal to the Library. It reuses logic to prevent code duplication in 'borrow' and 'delete' checks."
            },
            {
              "anchor": "tid for tid",
              "title": "List Comprehension",
              "content": "We use this advanced loop to find all related IDs in one line. It is faster and more readable than a manual loop."
            },
            {
              "anchor": "related_trans_ids",
              "title": "Safe Deletion",
              "content": "We calculate WHAT to delete before we start deleting. Modifying a dictionary while looping through it causes crashes."
            }
          ]
        }
      ]
    },
    {
      "id": "2",
      "title": "2. transact.py",
      "code": "from datetime import date\nfrom book import Book\nfrom user import User \n\nclass Transact:\n    # Type hints help tools.py identify nested dependencies\n    transactID: str\n    book: Book\n    user: User\n    borrowDate: date\n    returnDate: date\n    fine: float\n    \n    def __init__(self, transactID: str, book: Book, user: User, borrowDate=date.today(), returnDate=None, fine: float = 0.0): \n        # Private attributes for encapsulation\n        self.__transactID = str(transactID) \n        self.__book = book                  \n        self.__user = user                  \n        self.__borrowDate = borrowDate      \n        self.__returnDate = returnDate      \n        self.__fine = float(fine)\n\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # Properties (The Adapter Layer)\n    # Allows library.py to access 'transact.book' while keeping '__book' private\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    @property\n    def book(self) -> Book:\n        return self.__book\n\n    @property\n    def user(self) -> User:\n        return self.__user\n\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    # Standard Methods\n    # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n    def getTransactID(self) -> str:\n        return self.__transactID\n\n    def returnStatus(self):\n        \"\"\"Returns the return date. If None, the book is still borrowed.\"\"\"\n        return self.__returnDate\n\n    def returnTransact(self):\n        \"\"\"\n        Processes return: sets returnDate to today and calculates fine \n        if duration exceeds 7 days ($0.50/day).\n        Ref: \n        \"\"\"\n        self.__returnDate = date.today()\n        \n        # Calculate difference in days\n        difference = self.__returnDate - self.__borrowDate\n        \n        # Fine Logic: Only if duration > 7 days\n        if difference.days > 7:\n            overdue_days = difference.days - 7\n            self.__fine += 0.50 * overdue_days\n\n    def __str__(self):\n        # Format: ID | Book Title | User Name | Dates | Fine\n        # Uses getters/accessors from Book and User classes for clean display\n        status = self.__returnDate if self.__returnDate else \"Outstanding\"\n        return (f\"TransactID: {self.__transactID}\\n\"\n                f\"Book: {self.__book.getCallNo()} ({str(self.__book).splitlines()[1]})\\n\"\n                f\"User: {self.__user.getName()} ({self.__user.getUserID()})\\n\"\n                f\"Borrowed: {self.__borrowDate} | Returned: {status} | Fine: ${self.__fine:.2f}\")",
      "steps": [
        {
          "seq": "2.1",
          "lines": [23, 31],
          "caption": "Decorators",
          "add": [
            {
              "anchor": "@property",
              "title": "Property Decorator",
              "content": "The Pythonic way to implement getters. It allows us to access 'obj.book' like a normal variable, but underneath it executes a method to return the private '__book' securely."
            }
          ]
        },
        {
          "seq": "2.2",
          "lines": [46, 56],
          "caption": "Object Logic",
          "add": [
            {
              "anchor": "self.__returnDate - self.__borrowDate",
              "title": "Date Arithmetic",
              "content": "We subtract Date objects, not integers. Python returns a 'timedelta' object, handling calendar complexities automatically."
            }
          ]
        }
      ]
    },
    {
      "id": "3",
      "title": "3. book.py",
      "code": "# book.py\n\nclass Book:\n    # Type hints for Inspect module\n    callNo: str\n    title: str\n    author: str\n    ISBN: str\n    publisher: str\n\n    def __init__(self, callNo: str, title: str, author: str, ISBN: str, publisher: str):\n        # Private attributes for encapsulation\n        self.__callNo = str(callNo) \n        self.__title = str(title)\n        self.__author = str(author)\n        self.__ISBN = str(ISBN) \n        self.__publisher = str(publisher) \n\n    # Getter\n    def getCallNo(self) -> str:\n        return self.__callNo\n\n    def __str__(self):\n        return f\"{self.__callNo}\\n{self.__title}\\n{self.__author}\\n{self.__ISBN}\\n{self.__publisher}\"",
      "steps": []
    },
    {
      "id": "4",
      "title": "4. user.py",
      "code": "# user.py\n\nclass User:\n    # Type hints\n    userID: str\n    name: str\n    email: str\n    contact: int\n\n    def __init__(self, userID: str, name: str, email: str, contact: int):\n        # Fixed: Using private attributes consistent with Getters\n        self.__userID = str(userID)\n        self.__name = str(name)\n        self.__email = str(email)\n        self.__contact = int(contact)\n\n    def getUserID(self) -> str:\n        return self.__userID\n\n    def getName(self) -> str:\n        return self.__name\n\n    def __str__(self):\n        return f\"{self.__userID}\\n{self.__name}\\n{self.__email}\\n{self.__contact}\"\n\nclass Staff(User):\n    dept: str\n    def __init__(self, userID: str, name: str, email: str, contact: int, dept: str):\n        super().__init__(userID, name, email, contact)\n        self.__dept = str(dept)\n\n    def __str__(self):\n        return super().__str__() + f\"\\n{self.__dept}\"\n\nclass Student(User):\n    diploma: str\n    def __init__(self, userID: str, name: str, email: str, contact: int, diploma: str):\n        super().__init__(userID, name, email, contact)\n        self.__diploma = str(diploma)\n\n    def __str__(self):\n        return super().__str__() + f\"\\n{self.__diploma}\"",
      "steps": []
    },
    {
      "id": "5",
      "title": "5.constants.py",
      "code": "# constants.py\n\n# Menu Options\nOPTION_BOOKS = \"1\"\nOPTION_USERS = \"2\"\nOPTION_TRANSACTS = \"3\"\nOPTION_SAVE = \"4\"\nOPTION_EXIT = \"5\"\n\n# Sub-Menu Options\nACTION_ADD = \"1\"\nACTION_DISPLAY = \"2\"\nACTION_SEARCH = \"3\"\nACTION_DELETE = \"4\" \n\n# Nested Menu Options\nNESTED_CHOOSE_EXISTING = \"1\"\nNESTED_CREATE_NEW = \"2\"\n\n# Transaction Types\nTRANS_TYPE_BORROW = \"1\"\nTRANS_TYPE_RETURN = \"2\"\nTRANS_TYPE_ALL = \"3\"\n\n# Formatting\nDATE_FORMAT = \"%Y-%m-%d\"",
      "steps": []
    },
    {
      "id": "6",
      "title": "6. main.py",
      "code": "# main.py\nfrom library import Library\nfrom book import Book\nfrom user import User, Student, Staff\nfrom transact import Transact\nfrom tools import create_entity\nimport constants as C\nfrom init_data import load_test_data\n\n# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n# Menu Helpers\n# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\ndef sub_menu(item_name, allow_delete=False):\n    \"\"\"\n    Dynamically generates the sub-menu.\n    Args:\n        allow_delete: Boolean flag to show/hide the Delete option.\n    \"\"\"\n    print(f\"\\n--- {item_name} Management ---\")\n    print(f\"1. Add New {item_name}\")\n    print(f\"2. Display All {item_name}s\")\n    print(f\"3. Search {item_name}\")\n    if allow_delete:\n        print(f\"4. Delete {item_name}\")\n\ndef sub_loops(add_func, display_func, search_func, delete_func=None):\n    \"\"\"\n    Handles the sub-menu selection logic.\n    Args:\n        delete_func: Optional callable. If None, option 4 is ignored.\n    \"\"\"\n    sub_choice = input(\"Enter your action: \")\n    \n    if sub_choice == C.ACTION_ADD:\n        add_func()\n    elif sub_choice == C.ACTION_DISPLAY:\n        display_func()\n    elif sub_choice == C.ACTION_SEARCH:\n        search_func()\n    elif sub_choice == C.ACTION_DELETE and delete_func is not None:\n        delete_func() # Execute the passed delete method\n    else:\n        print(\"Invalid choice or option not available.\")\n\n# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n# Main Execution\n# â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\ndef main():\n    print(\"Initializing System...\")\n    my_lib = Library(\"SP Library\", \"Dover\", \"SG\")\n    load_test_data(my_lib)\n    \n    # Optional: Load test data if you have the init_data.py file from previous step\n    # from init_data import load_test_data\n    # load_test_data(my_lib)\n\n    # === Context Pools ===\n    context_pools = {\n        Book: my_lib.get_books_dict(),\n        User: my_lib.get_users_dict(),\n        Student: my_lib.get_users_dict(),\n        Staff: my_lib.get_users_dict()\n    }\n\n    while True:\n        print(f\"\\n_______ {my_lib} Menu _______\")\n        print(f\"1. Manage Books\")\n        print(f\"2. Manage Users\")\n        print(f\"3. Manage Transactions\")\n        print(f\"4. Save Data\")\n        print(f\"5. Exit\")\n        \n        choice = input(\"Enter your action: \")\n\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        # Option 1: Books (UPDATED with Delete)\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        if choice == C.OPTION_BOOKS:\n            sub_menu(\"Book\", allow_delete=True) # Enable Delete UI\n            \n            # Lambda wrapper to create entity before adding\n            add_logic = lambda: my_lib.addBook(create_entity(Book, context_pools))\n            \n            # Passing 4 functions now, including the new deleteBook\n            sub_loops(add_logic, my_lib.displayBooks, my_lib.getBook, my_lib.deleteBook)\n\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        # Option 2: Users (No Delete req in prompt, keeping standard)\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        elif choice == C.OPTION_USERS:\n            sub_menu(\"User\", allow_delete=False)\n            \n            def add_user_logic():\n                u_type = input(\"Type (1) Student or (2) Staff? \")\n                if u_type == \"1\":\n                    my_lib.addUser(create_entity(Student, context_pools))\n                elif u_type == \"2\":\n                    my_lib.addUser(create_entity(Staff, context_pools))\n                else: \n                    print(\"Invalid user type.\")\n\n            sub_loops(add_user_logic, my_lib.displayUsers, my_lib.getUser)\n\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        # Option 3: Transactions\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        elif choice == C.OPTION_TRANSACTS:\n            sub_menu(\"Transaction\", allow_delete=False)\n            \n            add_trans_logic = lambda: my_lib.borrowTransact(create_entity(Transact, context_pools))\n            \n            sub_loops(add_trans_logic, my_lib.displayTransact, my_lib.returnTransact)\n\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        # Option 4: Save\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        elif choice == C.OPTION_SAVE:\n            my_lib.save()\n\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        # Option 5: Exit\n        # â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”\n        elif choice == C.OPTION_EXIT:\n            print(\"Exiting system. Goodbye!\")\n            break\n        \n        else:\n            print(f\" ! Invalid input\")\n\nif __name__ == \"__main__\":\n    main()",
      "steps": [
        {
          "seq": "6.1",
          "lines": [78, 93],
          "caption": "Functional Logic",
          "add": [
            {
              "anchor": "lambda:",
              "title": "Deferred Execution",
              "content": "We wrap the 'addBook' call in a lambda. This ensures it doesn't run immediately, but waits until the user actually selects 'Add'."
            },
            {
              "anchor": "sub_loops",
              "title": "First-Class Functions",
              "content": "We pass functions (like my_lib.displayBooks) as arguments to other functions. The 'sub_loops' function decides when to run them."
            }
          ]
        }
      ]
    },
    {
      "id": "7",
      "title": "7. tools.py (Main program assistant tools)",
      "code": "import inspect\nfrom datetime import date\nfrom constants import NESTED_CHOOSE_EXISTING, NESTED_CREATE_NEW\n\n# Primitive data types\nPRIMITIVES = (str, int, float, bool, date, type(None))\n\ndef get_typed_input(name_of_input, checking_type):\n    while True:\n        function_input = input(f\"Enter value for {name_of_input} ({checking_type.__name__}): \").strip()\n        # Quiting logic\n        if function_input == \":q\":\n            print(\" >> Operation cancelled.\")\n            return None\n        \n        # Default condition\n        is_valid_format = True\n\n        # Email checking logic\n        if name_of_input == \"email\":\n            if '@' not in function_input or '.' not in function_input:\n                print(\" >> Format Error: Email must contain '@' and '.'.\")\n                is_valid_format = False\n\n        # validation for isbn\n        elif name_of_input == \"ISBN\":\n            if len(function_input.replace(\"-\", \"\")) < 13:\n                print(\" >> Format Error: ISBN length must be at least 13.\")\n                is_valid_format = False\n        # validation for phone number     \n        elif name_of_input == \"contact\":\n            if not function_input.isdigit():\n                print(\" >> Format Error: Contact must be digits only.\")\n                is_valid_format = False\n\n        # DEFAULT validation for non null input\n        if len(function_input) == 0:\n            print(\" >> Input cannot be empty\")\n            is_valid_format = False \n\n        if not is_valid_format:\n        # skip the the  try & except if is not valid\n            continue\n\n        \n        try:\n            return checking_type(function_input)\n        except ValueError:\n            print(f\" >> Type Error: Cannot convert input to {checking_type.__name__}.\")\n\n\n#-------------------------------------------------------------------------------\n\ndef nested_class(entity, storage_dict, context_pools):\n    \"\"\"\n    Handles nested selection logic.\n    [Fix]: No longer calls loop_input, directly uses simple while loop for menu selection.\n    \"\"\"\n    # Menu\n\n    print(f\"\\n______ {entity.__name__} Menu ______\")\n    print(f\"1. Choose from existing {entity.__name__}\")\n    print(f\"2. Create a new {entity.__name__}\")\n\n    # Prepare variable\n    choice = None\n    # Input Loop\n    while True:\n        function_input = input(\"Enter option (1/2): \").strip()\n\n        # Ensure valid input\n        if function_input in [NESTED_CHOOSE_EXISTING, NESTED_CREATE_NEW]:\n            choice = function_input\n            break\n        print(\" >> Invalid input, please enter 1 or 2.\")\n    \n    # Main loop\n\n    # ======================= Choosing for exist =============================\n\n    if choice == NESTED_CHOOSE_EXISTING:\n        # if condtion for output when dictionary is Empty\n        if not storage_dict:\n            print(f\" !! No existing {entity.__name__} found. Please create new.\")\n            return nested_class(entity, storage_dict, context_pools)\n        \n        # Displaying the exist Entity\n        print(f\"--- Available {entity.__name__} List ---\")\n        for key, obj in storage_dict.items():\n            # 1. Convert object to string and split lines\n            obj_string = str(obj)\n            lines = obj_string.splitlines()\n            \n            # 2. Prepare a variable to store the text to display\n            display_text = \"\"\n            \n            # 3. Use basic if-else logic\n            # If lines > 1 (usually title or name), show the second line\n            if len(lines) > 1:\n                display_text = lines[1]\n            # Otherwise (only one line or split failed), show the first line as fallback\n            else:\n                display_text = lines[0]\n\n            print(f\"ID: [{key}] => {display_text}\")\n        \n        # Choosing the entity by ID\n        while True:\n            target_id = input(f\"Enter ID to select: \").strip()\n            if target_id in storage_dict:\n                print(f\" >> Selected: {target_id}\")\n                return storage_dict[target_id]\n            print(\" !! ID not found, please try again.\")\n\n    # ======================= Creating Entity =============================\n\n    elif choice == NESTED_CREATE_NEW:\n        # 1. Create new object\n        new_obj = create_entity(entity, context_pools)\n        \n        # 2. Check if object created successfully and storage exists\n        if new_obj is not None and storage_dict is not None:\n            \n            # Get class name (string), e.g., \"Book\", \"Student\", \"Staff\"\n            class_name = entity.__name__\n            obj_id = None\n\n            # 3. Determine ID getter based on name (Basic if-else)\n            if class_name == \"Book\":\n                obj_id = new_obj.getCallNo()\n            elif class_name == \"Student\" or class_name == \"Staff\":\n                obj_id = new_obj.getUserID()\n            \n            # 4. If ID found, save to dictionary\n            if obj_id is not None:\n                storage_dict[obj_id] = new_obj\n                print(f\" >> [System] New {class_name} saved automatically.\")\n                \n        return new_obj\n    \n\n\n#=========================================================================================\n\ndef create_entity(target_entity_class, context_pools=None):\n    # 1. Safety check for context_pools\n    if context_pools is None: \n        context_pools = {}\n\n    print(f\"\\n--- Creating New {target_entity_class.__name__} ---\")\n    \n    # 2. Get the attributes from the class __init__ method\n    init_params = inspect.signature(target_entity_class.__init__).parameters\n    \n    # Get type hints as a backup (e.g., callNo: str)\n    annotations = getattr(target_entity_class, \"__annotations__\", {})\n    \n    # Dictionary to store user inputs\n    input_data = {} \n\n    # 3. Loop through each ingredient (parameter)\n    for param_name, param in init_params.items():\n        \n        # Skip 'self' \n        if param_name == 'self': \n            continue\n\n        # --- Step A: Determine the Data Type ---\n        # Basic logic to find the type (str, int, Book, etc.)\n        target_type = param.annotation\n        \n        # If inspect couldn't find the type, try looking in annotations, otherwise default to str\n        if target_type == inspect.Parameter.empty:\n            target_type = annotations.get(param_name, str)\n\n        # --- Step B: Handle Complex Types (Classes) ---\n        # Check if the type is a custom class (like Book) and not a basic type (like int/str)\n        is_class = inspect.isclass(target_type)\n        is_not_primitive = target_type not in PRIMITIVES\n\n        if is_class and is_not_primitive:\n            # Find the storage list for this type (e.g., find all Books)\n            storage = context_pools.get(target_type)\n            \n            # Go to the sub-menu to select an existing object or create a new one\n            selected_obj = nested_class(target_type, storage, context_pools)\n            \n            # If user cancelled inside nested_class, stop everything\n            if selected_obj is None: \n                return None \n            \n            # Save the result\n            input_data[param_name] = selected_obj\n            continue \n\n        # --- Step C: Handle Basic Types (Strings, Numbers) ---\n        \n        # Check if this parameter has a default value (e.g., fine=0.0)\n        has_default_value = param.default != inspect.Parameter.empty\n\n        if has_default_value:\n            # Ask user if they want to keep the default\n            print(f\"Attribute [{param_name}] has default value: '{param.default}'\")\n            choice = input(\"Do you want to modify it? (y/n): \").strip()\n            \n            # If user says anything other than 'y', keep the default and skip to next parameter\n            if choice.lower() != 'y':\n                input_data[param_name] = param.default\n                continue\n\n        # If no default (or user wants to modify), ask for input\n        val = get_typed_input(param_name, target_type)\n        \n        # If user typed :q to quit\n        if val is None: \n            return None \n        \n        # Save the input\n        input_data[param_name] = val\n\n    # 4. Final Step: Create the object using the collected data\n    # **input_data means \"unpack this dictionary into arguments\"\n    return target_entity_class(**input_data)",
      "steps": [
        {
          "seq": "7.1",
          "lines": [1, 2],
          "caption": "Imports",
          "add": [
            {
              "anchor": "import inspect",
              "title": "Module: Inspect",
              "content": "A powerful built-in module that lets code look at itself. We use it here to read class attributes and constructor arguments dynamically at runtime."
            }
          ]
        },
        {
          "seq": "7.2",
          "lines": [90, 100],
          "caption": "String Handling",
          "add": [
            {
              "anchor": "splitlines()",
              "title": "Method: Splitlines",
              "content": "A string method that breaks a large block of text into a list, splitting at every line break (\\n). Used here to parse the multi-line string output from __str__."
            }
          ]
        },
        {
          "seq": "7.3",
          "lines": [160, 175],
          "caption": "Dynamic Types",
          "add": [
            {
              "anchor": "getattr",
              "title": "Function: getattr",
              "content": "Standard function (obj, 'name'). It retrieves an attribute dynamically using a string name. It's safer than direct access because we can provide a default value (fallback)."
            },
            {
              "anchor": "isclass",
              "title": "Check: isclass",
              "content": "Distinguishes between a 'Class Blueprint' (e.g., Book) and an 'Instance' (e.g., Harry Potter). We use this to trigger the nested creation menu."
            }
          ]
        },
        {
          "seq": "7.4",
          "lines": [220, 225],
          "caption": "Unpacking",
          "add": [
            {
              "anchor": "**input_data",
              "title": "Dictionary Unpacking",
              "content": "The double-asterisk takes a dictionary like {'id':1, 'name':'Kai'} and expands it into named arguments: func(id=1, name='Kai')."
            }
          ]
        }
      ]
    }
  ]
}